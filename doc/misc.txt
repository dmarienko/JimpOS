
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
GCC -c my_kernel.c
LD my_kernel.o -o kernel.bin -oformat binary -Ttext 0x100000

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
#define Align(x,a)	(((x) + (a - 1)) & ~(a - 1))

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
In unreal mode, set up a GDT, switch to protected mode by setting
EFLAGS.PE=1 but don't reload CS. Load FS and GS (say) with a selector which
refers to a descriptor with base=0, limit=4GB. Switch back to real mode
(EFLAGS.PE=0). Now 32-bit memory accesses with the FS or GS overrides will
result in a fault if it is beyond 1MB.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
#include <stdio.h>

char *int2str (int x, char *buf) {
  if (x / 10) buf = int2str (x / 10, buf);
  *buf++ = '0' + x % 10;
  *buf = 0;
  return buf;
}

int main() {
  char buf[12];
  int2str (12345, buf);
  printf (buf);
  return 0;
}
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
/*
* This function resets computer. Used by f.e. CTRL+ALT+DEL handler :)
*/
void system_reset(void)
{
		while(inportb(0x64) & 0x02);
        outportb(0x64, 0xfe);
        asm("cli;hlt");
}
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Ну, сейчас я уже подробностей не вспомню, но в общих чертах работало это примерно так.
Приоритет потока - целое число от 0 и до ... много.
Существует также глобальный системный age шедулера. Это счетчик, начинающийся с 0x7fffffff, 
каждая операция шедулинга (то есть когда планировщик перетряхивает потоки), уменьшает этот 
счетчик на единицу. Существует очередь готовых к выполнению потоков, представляющая собой 
множество пар <age,thread_id>, упорядоченную по age. Когда некоторый поток i становится 
готовым к выполнению, для него вычисляется эффективный возраст:e_age = system_age+thread.prio
Поток вставляется в очередь согласно этому e_age, т.е. чем больше приоритет потока, а 
следовательно, и эффективный возраст, тем "глубже" он провалится в этой очереди. Самый 
"глубокий" (то есть с максимальным эффективным возрастом) поток в очереди выбирается для
выполнения. Уменьшение system_age с каждой операцией планирования дает то, что если два 
потока с одинаковым приоритетом будут поставлены друг за другом, их порядок сохранится, а 
главное - если есть поток с некоторым приоритетом, сидящий в очереди достаточно давно, то 
чтобы его обогнать и зашедулиться другому потоку, надо иметь достаточно высокий приоритет.
И наоборот, если максимальный приоритет потока, находящегося в системе ограничен, то даже 
поток с минимальным приоритетом гарантированно получит управление, причем не когда нибудь,
а через точно известное время, причем поддающееся вычислению.
Пример. Два потока с приоритетами 0 (поток A) и 10 (поток B).
Age = 1000.
1. Создаем поток A. Очередь: <1000,A>. Age=999.
2. Создаем поток B. Очередь: <1009,B>, <1000,A>. Age=998.
3. Выполняем B.
4. Ставим в очередь B: <1008,B>, <1000,A>. Age=997
5. Опять выполняем B.
.... и так еще много раз
N. Age=989. Ставим в очередь B: <1000,A>, <999,B>. Age=988.
N+1. Выполняем A.
N+2. Ставим в очередь A: <999,B> <998,A>.
N+3. Выполняем B.
Таким образом, время между потоками делится пропорционально их приоритетам. Там еще были 
навороты, связанные с различными правилами планирования etc, но их я уже не помню.
